- [Part 1: Adopt the Right Mindset](#part-1-adopt-the-right-mindset)
  * [Chapter 1 Focus on High-Leverage Activities](#chapter-1-focus-on-high-leverage-activities)
  * [Chapter 2 Optimise for learning](#chapter-2-optimise-for-learning)
  * [Chapter 3 Prioritise Regularly](#chapter-3-prioritise-regularly)
- [Part 2: Execute, Execute, Execute](#part-2-execute-execute-execute)
  * [Chapter 4 Invest in iteration speed](#chapter-4-invest-in-iteration-speed)
  * [Chapter 5 Measure What You Want to Improve](#chapter-5-measure-what-you-want-to-improve)
  * [Chapter 6 Validate Your Ideas Early and Often](#chapter-6-validate-your-ideas-early-and-often)
  * [Chapter 7 Improve Your Project Estimation Skills](#chapter-7-improve-your-project-estimation-skills)
- [Part 3: Build Long-Term Value](#part-3-build-long-term-value)
  * [Chapter 8 Balance Quality with Pragmatism](#chapter-8-balance-quality-with-pragmatism)
  * [Chapter 9 Minimize Operational Burden](#chapter-9-minimize-operational-burden)
  * [Chapter 10 Invest in Your Team's Growth](#chapter-10-invest-in-your-teams-growth)
____

#### Reference

- [The Effective
  Engineer](https://www.amazon.com/Effective-Engineer-Engineering-Disproportionate-Meaningful/dp/0996128107)
  by Edmond Lau

## Part 1: Adopt the Right Mindset

### Chapter 1 Focus on High-Leverage Activities

- Two highest leverage investment
  - onboard program
    - tech talks
    - code labs
      - going through design documents
      - teaching development tools and debugging tools
  - mentoring program
    - code review
    - outlining technical skills to learn
    - pair programming
    - discussing engineering trade-offs
    - explaining how to prioritise better
    - offering guidance on how to work well with different team members
    - plan a sequence of starter tasks and projects to increase the new hires’
      mastery of systems
- Leverage = Impact / Time invested
  - Time is the most limited resource
- Meeting leverages
  - preparing an agenda and a set of goals for the meeting and circulating them
    to attendees beforehand so that the meeting is focused and more productive
  - if an in-person discussion is not actually necessary, replacing the meeting
    with an email discussion and spending the time building an important feature
- Development leverages
  - automating parts of the development or testing process that have thus far
    been done manually, so that you can iterate more quickly
  - talking with the customer support team to gain insights into the customers’
    biggest pain points, and using that knowledge to understand whether there
    are other features you could be working on that would produce even more
    value with less development effort
- Performance enhancement leverages
  - learning to effectively use a profiling tool so that you can reduce the time
    it takes to identify each bottleneck
  - measuring both the performance and visit frequency of each web page so that
    you can address the bottlenecks that affect the most traffic first, thereby
    increasing the impact of each fix you make
- Making hiring is a high leverage task
  - engineers should not skip interviews to do other work
  - the best would be to submit feedback immediately
  - allocate the best time-slot when recruiters needed to schedule interviews
    with candidates


### Chapter 2 Optimise for learning

- Applying for a job
  - Fast growth
    - At fast-growing teams and companies, the number of problems to solve
      exceeds available resources, providing ample opportunities to make a big
      impact and to increase your responsibilities
    - Easier to attract strong talent and build a strong team
  - Training
    - Strong on-boarding programs demonstrate that the organization prioritises
      training new employees
  - Openness
    - Openness to incorporate feedback into the future iterations
      - Examples
        - Conduct post-mortems after outages
        - Document insider-knowledge
        - One team knows what the other team does
  - Pace
    - Fast iterations
    - Automation tools
    - Lightweight approval processes
    - A willingness to experiment accelerate progress
      - Examples
        - Check the percentage of time spent on maintenance versus developing
          new products and features
  - People
    - Smarter people around means surrounding yourself with potential teachers
      and mentors
  - Autonomy
    - The freedom to choose what to work on and how to do it drives our ability
      to learn
    - The freedom to change teams
- Examples on 20% time
  - Develop a deeper understanding of areas you are already working on and tools
    that you already use
  - Adjacent disciplines
    - Product engineer
      - Product management
      - User research
      - Backend engineering
    - Infrastructure engineer
      - Machine learning
      - Database internals
      - Web development
    - Growth engineer
      - Data science
      - marketing
      - Behavioural psychology
- Suggestions on 20% time
  - Study code for core abstractions written by the best engineers at your
    company
  - Write more code
  - Go through any technical, educational material available internally
  - Master the programming languages that you use
  - Send your code reviews to the harshest critics
  - Enroll in classes on areas where you want to improve
  - Participate in design discussion of projects you are interested in
  - Work on a diversity of projects
  - Make sure you are on a team with at least few senior engineers whom you can
    learn from
  - Jump fearlessly into code you don’t know
- Always learning
  - Learn new programming languages and frameworks
  - Invest in skills that are in high demand
  - Read books
  - Join a discussion group
  - Attend talks, conferences and meet-ups
  - Build and maintain a strong network of relationships
  - Follow bloggers who teach
  - Write to teach

### Chapter 3 Prioritise Regularly

- Prioritisation
  - hard work
  - Requires practice
  - Misallocate time is okay, as long as there is retrospective, things will be
    improved
- Checklist
  - The first step in effective prioritisation is listing every task that you
    might need to do
    - Human brain is optimised for processing and not for storage
    - Brainpower is much better spent on prioritising our work and solving
      engineering problems than on remembering everything we need to do
  - Properties
    - A canonical representation of work (and a single list)
    - Easily accessible
- Tips on prioritisation
  - Compile a small number of goals that are important to complete, pick
    initial tasks toward those goals and then make a pairwise comparison between
    what you are currently doing and what else is on the to-do list
    - Reason
      - It is not actually useful to know that the 100th task provides higher
        leverage than 101st task
  - The goal is not to establish a total ordering of all your priorities
    - Any ordering made will be based on imperfect information
  - Iterate on the question
    - Is there something else I could be doing that is higher-leverage?
    - Continuously shift your top priorities toward the ones with the highest
      leverage, given the information available at the time
- Focuses
  - On what directly produces value
  - On the important and non-urgent
    - To priorities the investments that increase our ability to be more
      effective and deliver more value in the future
    - Examples
      - Planning career goals
      - Building stronger relationships
      - Reading books and articles for professional development
      - Adopting new productivity and efficiency habits
      - Building tools to improve our workflows
      - Investing in useful abstractions
      - Ensuring that infrastructure will continue to scale
      - Learning new programming languages
      - Speaking at conferences
      - Mentoring our teammates to help them be more productive
      - Prioritisation of tasks
    - If there is too much time spend on important and urgent activities
      (fire-fighting)
      - It is a sign that the root cause is underinvestment in important and
        non-urgent activities
        - Examples
          - Frequent pager duty alerts might indicate a need for automated
            recovery procedures
          - High-priority bugs might be a symptom of low test coverage
          - Constant deadlines might be caused by poor project estimation and
            planning
- Protecting schedule of maker (developer)
  - Not to be influenced too much by meeting schedule
  - Empirical research highlights the cost of breaking schedule of a maker
    (developer)
    - Typically from 10 to 23 minutes
  - Managers tend to schedule things into one-hour blocks
  - Makers (developers) tend to schedule things into a day or half a day
- Avoid multitasking
  - When we fragment our attention too much, we end up reducing our overall
    productivity and hindering our ability to make substantive progress on any
    one thing
  - When a team fragment their efforts across too many tasks, they stop sharing
    the same context for design discussions or code reviews. Completing
    priorities divide the team and, momentum on any one activity slows down
- Fight procrastination with if-then plans
  - Subconscious follow-up is important because procrastination primarily stems
    from a reluctance to expend the initial activation energy on a task
  - When we make if-then plans and decide what to do ahead of time, it is more
    likely to consider the long-term benefits associated with a task
- An example of to-do list
  - Sections
    - Current priorities
      - Doing
      - Today
      - This week
    - Backlog

## Part 2: Execute, Execute, Execute

### Chapter 4 Invest in iteration speed

- Continuous deployment
  - Elements
    - Tools to automate versioning and packaging
    - Testing framework that parallelised thousands of unit and integration
      tests across a tier of worker machines
    - Investing in dashboards and alerts that monitor health of products
    - Tools to easily roll back changes in the event that some bad code had
      fallen through the cracks
  - Reasons
    - Eliminated the manual overhead associated with each deployment
    - Giving high confidence that each deployment is just business as usual
- Invest in time-saving tools
  - Examples
    - Use a language that allows REPL (read-eval-print-loop)
    - Hot code reloads
    - Continuous integration
- Shortening the debugging and validation loops
  - Structuring (or architecting) the code properly with correct dependencies
    which is mockable
  - Find ways to shorten the loop every time a bug is found
- Mastering programming environment
  - Get proficient with a text editor or IDE
  - Learn at least one productive, high-level programming language
    - Like python or ruby but not C/C++
  - Get familiar with shell commands
    - Examples
      - `grep`, `sort`, `uniq`, `wc`, `awk`, `sed`, `xargs`, `find`
  - Prefer the keyboard over the mouse
  - Automate manual workflow
    - Example
      - Shell scripts
      - Browser extension
      - Hot browser reload
  - Test out ideas on an interactive interpreter
  - Make it fast and easy to run just the unit tests associated with current
    changes
    - Integrate unit tests into text editor or IDE

### Chapter 5 Measure What You Want to Improve

- Metrics to measure
  - 95th or 99th percentile response times
    - Rather than average response times
  - Bugs outstanding
    - Rather than bugs fixed
  - Weekly growth rate of registered users
    - Rather than registered users
  - Weekly active rate by age of cohort
    - Rather than weekly active users
- Choosing a metric
  - Maximise impact
  - Actionable (can be explained by team’s effort)
  - Responsive (one can be quickly reflected)
- Measuring everything to understand what is going on
  - To keep the team on-track with short-term goals
- measure every metrics and present them onto a dashboard
- getting to know what the normal metrics are helps understanding abnormalities
  when there are exceptions
- adopting a mindset of instrumentation means ensuring the team have a set of
  dashboards that surface key health metrics and that enable a team member to
  drill down the relevant data
- tools
  - [Graphite](https://graphiteapp.org/)
  - [StatsD](https://github.com/statsd/statsd)
  - [InfluxDB](https://www.influxdata.com/)
  - [Ganglia](http://ganglia.sourceforge.net/)
  - [Nagios](https://www.nagios.org/)
  - [munin](https://munin-monitoring.org/)
  - [New Relic](https://newrelic.com/)
  - [AppDynamics](https://www.appdynamics.com/)
- successful technology companies build the equivalent of a pilot's flight
  instruments, making it easy for engineers to measure, monitor, and visualise
  system behaviour
- strategies on metric gathering
  - log data liberally, in case it turns out to be useful later on
  - build tools to iterate on data accuracy sooner (for example, tools to
    analyse logs)
  - write end-to-end integration tests to validate your entire analytics
    pipeline
  - examine collected data sooner
  - cross-validate data accuracy by computing the same metric in multiple ways
  - when a number does look off, dig in to it early

### Chapter 6 Validate Your Ideas Early and Often

- failing example of [Cuil](https://en.wikipedia.org/wiki/Cuil) (a search
  engine)
  - Cuil had wanted to make a big splash at launch and feared leaking details to
    the press, they had not hired any alpha testers to play around with the
    product.
  - prior to launch, there was no external feedback to point out that the search
    quality was not there, that the search engine was not returning enough
    results, and that users did not care about the size of index if it did not
    actually lead to higher quality results
  - an improved example of [BloomReach](https://www.bloomreach.com/en)
    - build a MVP in 4 months and release it to beta customers
    - getting feedback from beta customers and the feedback helps to determine
      what to build next
- an iterative approach
  - the shorter each iteration cycle, the more quickly we can learn from our
    mistakes; the longer the iteration cycle, the more likely it is that
    incorrect assumptions and errors will compound
  - thus, investment in iteration speed is important
- demystifying the riskiest areas first allows updating of plan and avoiding
  nasty surprises
- always ask the question
  - can I expend a small fraction of the total effort to collect some data nad
    validate that what I'm doing will work?
    - hesitation of adding 10% extra overhead to do this as
      - in a hurry, or
      - over confident about the implementation plans
- MVP (minimum viable product)
  - allows a team to collect the maximum amount of validated learning about
    customers with the least effort
  - validate hypotheses about your users as much as possible
  - example
    - a 4-minute video as a MVP of Dropbox
  - for smaller project, a prototype can be used for the same effect
  - fake implementation
    - example
      - Asana used a fake sign-in by Google button and show message "Thanks for
        your interest" to determine whether they should implement such a button
- A/B testing
  - a random subset of users sees a change or a new feature; everyone else in
    the control group does not
  - it works by comparing metrics (assuming the assignment to a group was not
    biased)
  - it helps quantifying an idea/theory to see how much effort should be spent
  - it encourages an iterative approach
  - tools
    - [Feature API](https://github.com/etsy/feature) from Etsy
    - [vanity](https://github.com/assaf/vanity) using Ruby
    - [Optimizely](https://www.optimizely.com/)
    - [Apptimize](https://apptimize.com/)
    - [Unbounce](https://unbounce.com/a-b-testing/)
    - [Visual Website Optimizer](https://vwo.com/)
- one-person team
  - an anti-pattern
  - feedback loop is hard to exist
  - small blocking issues could last longer
  - monotonous work cannot be shared
  - suggestions
    - be open and receptive to feedback
    - commit code early and Often
    - request code reviews from thorough critics
    - ask to bounce ideas off your teammates
    - design the interface or API of a new system first
    - send out a design document before devoting time to code
    - solicit buy-in for controversial features before investing too much time
- feedback loop
  - examples
    - tying bonuses to engineering-wide metrics like reliability
      - it is hard when the metrics are not clear-cut

### Chapter 7 Improve Your Project Estimation Skills

- project planning
  - have estimates before discussion about deadlines
- to create an accurate estimate
  - decompose a project into granular tasks
    - if a task takes more than 2 days, decompose it further
    - a long estimate is a hiding place for nasty surprises
    - easier to defend when a manager challenges it
  - let the person doing the actual task to make the estimate
    - it adapts to different skill set and familiarities
  - beware of anchoring bias
    - mostly due to manager give an estimate beforehand
  - beware of the mythical man-month
    - a task has an estimate of 1 man-week does not mean two developers can
      complete it in 2.5 days as the are other overheads
  - validate estimates against historical data
  - use timeboxing to constraint tasks that can grow in scope
  - allow others to challenge estimates
    - increase accuracy
    - increase buy-in
- budget for unknown
  - at Asana, one engineering day is mapped to two workdays
- define specific goals
  - this allows separation of must-have and nice-to-have tasks
  - alignment with stakeholders for the assumptions involved
  - helps developer in making local trade-offs
  - avoids developer disappearing in a rabbit hole for a week (a long period of
    time)

## Part 3: Build Long-Term Value

### Chapter 8 Balance Quality with Pragmatism

- pragmatism
  - thinking in terms of what does and does not work for achieving goals
  - instead of right way or wrong way
- advantages of code review
  - catching bugs or design shortcomings early
  - increasing accountability of code changes
  - provide modelling of how to write good code
  - sharing working knowledge of codebase
  - increasing long-term agility
- a sustainable code review process
  - a process can be adapted to different situations/companies to get a good
    balance between quality and throughput
- abstractions
  - it is useful and help saving time to maintenance as it is in one piece
  - be aware of creating an abstraction too early where time could be wasted or
    abstraction could be built poorly due to lack of information (which makes
    the design too generic or overfitted)
- technical debt
  - all the deferred work that is necessary to improve the health and quality of
    the codebases that would slow things down if left unaddressed
  - it could be added due to insufficient understanding of the problem space
    initially
  - example solutions
    - at Asana, a week of each quarter to pay of debts
    - "code purge day" to remove old un-used code

### Chapter 9 Minimize Operational Burden

- maintenance cost associated with a complex architecture
  - engineering expertise gets splintered across multiple systems
    - as each system/technology has its own unique set of properties or failure
      modes
  - increased complexity introduces more potential single point of failure
    - surface area increases and it is hard to find more than 2 people covering
      the same area
  - new engineers face a steeper learning curve
  - efforts towards improving abstractions, libraries, and tools get diluted
    across the different systems/technologies
    - end up with less tools or libraries created
- (bad) techniques to fail slowly
  - handle exceptions to allow the program to continue to run
  - setting misconfigured parameters to default values
  - adding catch-all exception handlers to deal with unexpected issues
  - swallowing unexpected return values
- drawbacks of fail slowly
  - less decipherable bugs further down the road
  - hard to reason when the request path contains multiple systems
- relentlessly automate mechanical tasks
  - the incentive is lowered if the manual work is spread across the team
  - it is harder when engineers are not familiar with automation tools like bash
    scripts
  - internalizing the time it takes to complete the manual work helps the team
    to understand the time wasted
- make automated process idempotent
  - or at least retryable or reentrant
  - for infrequent schedules, make dry-run in-between schedules to allow
    errors/problems surface sooner
- production failures
  - script the decision-making process for all possible scenarios such that, in
    case a failure happens, we can respond quickly and in a planned-manner

### Chapter 10 Invest in Your Team's Growth

- hiring
  - standardisation across interviews
  - organised process for sourcing new candidates
  - formalised campus recruiting efforts
- goals of a good interview process
  - screens for the type of people likely to do well on the team
  - gets candidates excited about the team, the mission and the culture
    - even with no offer, candidates would refer their friends to interview with
      the company
- hands-on interview is the trend
- improving interview process
  - take time with your team to identify which qualities in a potential teammate
    you care about the most
    - examples
      - coding aptitude
      - mastery of programming
      - languages
      - algorithms
      - data structures
      - product skills
      - debugging
      - communications skills
      - culture fit
  - periodically discuss how effective the current recruiting and interview
    processes are; keep iterating until the process can accurately access the
    skills and qualities
  - design interview problems with multiple layers of difficulty that you can
    tailor to the candidate's ability by adding or removing variables and
    constraints
    - layered problems tend to provide more fine-grained signals about
      a candidate's ability than binary ones, where the candidate either gets
      the answer or he/she does not
  - control the interview pace to maintain a high signal-to-noise ratio
    - do not let interviewees ramble, get stumped, or get sidetracked for too
      long
  - scan for red flags by rapidly firing short-answer questions to probe a wide
    surface area
  - periodically shadow or pair with another team member during interviews
    - helps calibrate ratings across interviewers and provide opportunities to
      give each other feedback on improving the interview process
- on-boarding
  - without a good process
    - developers layout different subsets of concepts to new joins
      - easy for useful information to be omitted among the scattered
        explanations
    - initial work of a new join may not touch the core abstractions and he/she
      cannot learn about it
    - expectations could not be communicated clearly which leads to a new join
      spending too much time of documentation than on fixing bugs or
      making enhancements
  - examples
    - pairing a new hire with a mentor
      - mentor assigns small features or bugs from their task lists to do as
        starter projects
      - mentor has context of the tasks which guidance can provided
      - free mentors to shift their attention from less-interesting tasks to
        higher-leverage projects that they are better suited to tackle
      - mentors are encouraged to spend time to ramp up the new hire than to do
        other tasks
- shared code ownership
  - to avoid the bus factor of 1
  - strategies
    - avoid one-person team
    - review each other's code and design
    - rotate different types of tasks and responsibilities across teams
    - keep code readable and code quality high
    - present tech talks on software decisions and architecture
    - document your software, either through high-level design documents or in
      code-level comments
    - document the complex workflows or non-obvious workarounds necessary for
      you to get things done
    - invest time in teaching mentoring other team members
- post-mortems
  - it requires aligning behind a common goal of improving the product or team,
    and not focusing on where to assign blame
  - it requires being open and receptive to feedback, with the goal of building
    collective wisdom around what went wrong and what could have been done
    better
